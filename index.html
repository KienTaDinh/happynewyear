<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Heart Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        #back-button {
            position: absolute; top: 10px; right: 10px;
            background: linear-gradient(90deg, #d4af37, #ffd700);
            border: none; border-radius: 4px;
            color: #400; font-weight: bold; cursor: pointer;
            font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;
            padding: 8px 12px; z-index: 101; display: none;
            transition: 0.3s; box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
        #back-button:hover { transform: scale(1.05); box-shadow: 0 0 10px #ffd700; }

        #ui-layer { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            z-index: 100; width: 350px; 
            transition: opacity 0.5s; 
        }

        .control-panel {
            pointer-events: auto; background: rgba(20, 0, 0, 0.95); border: 2px solid #ffd700;
            color: #fff; padding: 25px; border-radius: 16px; backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
        }
        .control-panel h2 { margin-top: 0; text-align: center; color: #ffd700; text-transform: uppercase; font-size: 18px; margin-bottom: 20px;}
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; color: #ff8888; font-size: 12px; margin-bottom: 5px; text-transform: uppercase; font-weight: bold;}
        input[type="file"] { width: 100%; color: #fff; font-size: 12px; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 4px; box-sizing: border-box;}
        
        .color-row { display: flex; gap: 10px; }
        input[type="color"] {
            flex: 1; height: 40px; border: none; padding: 2px;
            background: rgba(255,255,255,0.1); border-radius: 4px; cursor: pointer;
        }

        #btn-confirm {
            width: 100%; padding: 12px; margin-top: 10px;
            background: linear-gradient(90deg, #d4af37, #ffd700);
            border: none; border-radius: 6px; color: #400; font-weight: bold; cursor: pointer;
            font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
            transition: 0.3s;
        }
        #btn-confirm:hover { transform: scale(1.02); box-shadow: 0 0 15px #ffd700; }

        #input-video { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: -1; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020202; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 999;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid #222;
            border-top: 4px solid #d4af37; border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        canvas { width: 100vw !important; height: 100vh !important; object-fit: contain; display: block; }
        
        .guide-text {
            position: fixed; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="color: #666; font-size: 12px; letter-spacing: 3px;">LOADING MAGIC...</div>
    </div>

    <button id="back-button">‚¨Ö BACK</button>

    <div id="ui-layer">
        <div class="control-panel" id="main-panel">
            <h2>C√†i ƒë·∫∑t H·ªôp qu√†</h2>
            
            <div class="control-group">
                <label>1. Ch·ªçn Nh·∫°c n·ªÅn</label>
                <input type="file" id="music-input" accept="audio/*">
            </div>
            
            <div class="control-group">
                <label>2. Ph·ªëi M√†u C√¢y Th√¥ng (Ch·ªçn 2 m√†u)</label>
                <div class="color-row">
                    <input type="color" id="color-1" value="#8A2BE2" title="M√†u ch·ªß ƒë·∫°o">
                    <input type="color" id="color-2" value="#FFD700" title="M√†u xen k·∫Ω">
                </div>
            </div>
            <div class="control-group">
                <label>3. Ch·ªçn M√†u Tr√°i Tim & Ch·ªØ</label>
                    <input type="color" id="heart-color-input" value="#FF69B4">
            </div>
            
            <div class="control-group">
                <label>3. Ch·ªçn ·∫¢nh (Kh√¥ng gi·ªõi h·∫°n)</label>
                <input type="file" id="photo-input" accept="image/*" multiple>
                <div style="font-size: 10px; color: #aaa; margin-top: 5px; font-style: italic;">*M·∫πo: Ch·ªçn bao nhi√™u ·∫£nh s·∫Ω c√≥ b·∫•y nhi√™u h·ªôp qu√†.</div>
            </div>
            
            <button id="btn-confirm">B·∫ÆT ƒê·∫¶U</button>
        </div>
    </div>
    
    <div class="guide-text">
        ‚úä N·∫Øm tay: C√¢y Th√¥ng | üëå Ok/B√∫ng tay: M·ªü qu√† | ü´∂ 2 tay gh√©p tim: I Love You
    </div>

    <video id="input-video" autoplay playsinline muted></video>
    <audio id="bg-music" loop crossorigin="anonymous"></audio>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0';

        // --- GLOBAL VARIABLES ---
        const uiLayer = document.getElementById('ui-layer');
        const btnConfirm = document.getElementById('btn-confirm');
        const backButton = document.getElementById('back-button');
        const audioEl = document.getElementById('bg-music');
        
        // Nh·∫°c m·∫∑c ƒë·ªãnh: Last Christmas
        const DEFAULT_MUSIC_URL = 'music.mp3'; 
        audioEl.src = DEFAULT_MUSIC_URL; 

        // ·∫¢nh m·∫∑c ƒë·ªãnh
        let PHOTOS = [
            { url: 'image1.jpg' }, 
            { url: 'image2.jpg' },
            { url: 'image3.jpg' },
            { url: 'image4.jpg' },
            { url: 'image5.jpg' }
        ];

        const CONFIG = {
            goldCount: 3000, redCount: 500, giftCount: 150,
            explodeRadius: 50, photoOrbitRadius: 25, 
            treeHeight: 60, treeBaseRadius: 25, 
            snowCount: 2000
        };

        // Qu·∫£n l√Ω m√†u s·∫Øc
        let treeColor1 = new THREE.Color("#8A2BE2"); // T√≠m
        let treeColor2 = new THREE.Color("#FFD700"); // V√†ng
        let heartColor = new THREE.Color("#FF69B4"); // H·ªìng

        let scene, camera, renderer, mainGroup;
        let groupGold, groupRed, groupGift, snowSystem;
        let giftObjects = [], photoMeshes = [], camPreviewMesh;
        let titleMeshTree, titleMeshGallery, starMesh, loveMesh;
        let handLandmarker, videoElement;
        
        let state = 'TREE'; 
        let selectedIndex = 0;
        let handX = 0.5, lastHandX = 0.5;
        let currentRotY = 0;
        let lastPinchTime = 0;

        // --- UI & EVENT HANDLERS ---
        function resetToSetup() {
            uiLayer.style.display = 'block';
            backButton.style.display = 'none';
            audioEl.pause();
            audioEl.currentTime = 0;
            state = 'TREE';
            selectedIndex = 0;
            
            // Reset tr·∫°ng th√°i qu√†
            giftObjects.forEach(obj => {
                if (obj.isOpen) {
                    gsap.to(obj.photo.scale, {x:0, y:0, z:0, duration: 0.1, onComplete: () => { obj.photo.visible = false; }});
                    obj.boxModel.visible = true;
                    gsap.to(obj.boxModel.scale, {x:1, y:1, z:1, duration: 0.1});
                    obj.isOpen = false;
                }
            });
            mainGroup.rotation.y = 0;
            currentRotY = 0;
        }

        btnConfirm.addEventListener('click', () => {
            uiLayer.style.display = 'none';
            backButton.style.display = 'block';
            if(audioEl.src) audioEl.play().catch(e => console.log("C·∫ßn t∆∞∆°ng t√°c ƒë·ªÉ ph√°t nh·∫°c"));
        });

        backButton.addEventListener('click', resetToSetup);

        document.getElementById('photo-input').addEventListener('change', (e) => {
            const fs = Array.from(e.target.files);
            if(fs.length > 0){
                PHOTOS = fs.map(f => ({ url: URL.createObjectURL(f) }));
                rebuildGiftBoxes();
            }
        });

        document.getElementById('music-input').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(f){ audioEl.src = URL.createObjectURL(f); } 
            else { audioEl.src = DEFAULT_MUSIC_URL; }
        });

        // X·ª≠ l√Ω ƒë·ªïi m√†u
        const colorInput1 = document.getElementById('color-1');
        const colorInput2 = document.getElementById('color-2');
        const heartInput = document.getElementById('heart-color-input');

        function onColorChange() {
            treeColor1.set(colorInput1.value);
            treeColor2.set(colorInput2.value);
        }
        if(colorInput1 && colorInput2) {
            colorInput1.addEventListener('input', onColorChange);
            colorInput2.addEventListener('input', onColorChange);
        }

        if(heartInput) {
            heartInput.addEventListener('input', (e) => {
                heartColor.set(e.target.value);
                if(loveMesh) loveMesh.material.color.set(heartColor);
            });
        }

        // --- TEXTURES ---
        function createCustomTexture(type) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d'); const cx = 64, cy = 64;
            
            if (type === 'gold_glow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grd.addColorStop(0, '#FFFFFF'); grd.addColorStop(0.2, '#FFFFE0'); grd.addColorStop(0.5, '#FFD700'); grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);
            } 
            else if (type === 'red_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFAAAA'); grd.addColorStop(0.3, '#FF0000'); grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);
            } 
            else if (type === 'snow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, 'rgba(255,255,255,1)'); grd.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);
            }
            return new THREE.CanvasTexture(canvas);
        }
        const textures = { 
            gold: createCustomTexture('gold_glow'), 
            red: createCustomTexture('red_light'), 
            snow: createCustomTexture('snow')
        };

        // --- THREE.JS SETUP ---
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.002);

            const WIDTH = window.innerWidth; const HEIGHT = window.innerHeight; const ASPECT = WIDTH/HEIGHT;
            camera = new THREE.PerspectiveCamera(60, ASPECT, 0.1, 1000);
            camera.position.set(0, 0, 110); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(WIDTH, HEIGHT, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(10, 20, 10); scene.add(dirLight);
            const pointL = new THREE.PointLight(0xffaa00, 1, 50); pointL.position.set(0, 10, 20); scene.add(pointL);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.5);
            groupRed = createParticleSystem('red', CONFIG.redCount, 4.0);
            groupGift = createParticleSystem('gold', CONFIG.giftCount, 3.5); 

            createSnow();
            createDecorations();
            rebuildGiftBoxes();
            
            const camGeo = new THREE.PlaneGeometry(32, 24);
            const camMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            camPreviewMesh = new THREE.Mesh(camGeo, camMat);
            camPreviewMesh.scale.x = -1; 
            const camGroup = new THREE.Group();
            camGroup.add(camPreviewMesh);
            camPreviewMesh.position.set(-70, -40, -100); 
            camera.add(camGroup);
            scene.add(camera);
        }

        function rebuildGiftBoxes() {
            giftObjects.forEach(obj => {
                mainGroup.remove(obj.group);
                obj.group.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if(Array.isArray(child.material)) child.material.forEach(m=>m.dispose());
                        else child.material.dispose();
                    }
                });
            });
            giftObjects = [];
            photoMeshes = [];

            const boxGeo = new THREE.BoxGeometry(12, 10, 12);
            const photoGeo = new THREE.PlaneGeometry(14, 10.5); 
            const photoBaseMat = new THREE.MeshBasicMaterial({color:0x222222, side:THREE.DoubleSide});
            const borderGeo = new THREE.PlaneGeometry(15, 11.5);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); 
            const redMat = new THREE.MeshPhongMaterial({ color: 0xD32F2F, shininess: 30, emissive: 0x330000 });
            const goldMat = new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 100, emissive: 0x443300 });

            if (PHOTOS.length > 8) CONFIG.photoOrbitRadius = 45;
            else CONFIG.photoOrbitRadius = 35;

            for(let i=0; i < PHOTOS.length; i++) {
                const container = new THREE.Group();
                const giftGroup = new THREE.Group();

                giftGroup.add(new THREE.Mesh(boxGeo, redMat));
                giftGroup.add(new THREE.Mesh(new THREE.BoxGeometry(3, 10.1, 12.1), goldMat));
                giftGroup.add(new THREE.Mesh(new THREE.BoxGeometry(12.1, 10.1, 3), goldMat));
                
                const lid = new THREE.Mesh(new THREE.BoxGeometry(13, 2, 13), redMat);
                lid.position.y = 5.5; giftGroup.add(lid);
                
                const bowGeo = new THREE.TorusGeometry(2, 0.5, 8, 16);
                const bow1 = new THREE.Mesh(bowGeo, goldMat); bow1.position.set(0, 7, 0); bow1.rotation.set(0,0,0.5); giftGroup.add(bow1);
                const bow2 = new THREE.Mesh(bowGeo, goldMat); bow2.position.set(0, 7, 0); bow2.rotation.set(0,0,-0.5); giftGroup.add(bow2);

                container.add(giftGroup);

                const photoMesh = new THREE.Mesh(photoGeo, photoBaseMat.clone());
                photoMesh.scale.set(0, 0, 0); photoMesh.position.set(0, 2, 0.5); photoMesh.visible = false;
                const borderMesh = new THREE.Mesh(borderGeo, borderMat.clone());
                borderMesh.position.z = -0.1; photoMesh.add(borderMesh);
                container.add(photoMesh);
                
                container.visible = false;
                mainGroup.add(container);
                photoMeshes.push(photoMesh);
                
                const rY = (Math.random() - 0.5) * 40;
                giftObjects.push({ group: container, boxModel: giftGroup, photo: photoMesh, border: borderMesh, isOpen: false, randomY: rY });
            }
            updatePhotoTextures();
        }

        function updatePhotoTextures() {
            photoMeshes.forEach((mesh, i) => {
                if (PHOTOS[i]) {
                    new THREE.TextureLoader().load(PHOTOS[i].url, (tex) => {
                        mesh.material.map = tex; mesh.material.color.setHex(0xffffff); mesh.material.needsUpdate = true;
                    });
                }
            });
        }

        function toggleGift() {
            if (state !== 'GALLERY') return;
            if (giftObjects.length === 0) return;
            selectedIndex = selectedIndex % giftObjects.length; 
            
            const selectedGift = giftObjects[selectedIndex];

            if (selectedGift.isOpen) {
                gsap.to(selectedGift.photo.scale, {x:0, y:0, z:0, duration: 0.4, ease: "back.in(1.7)", onComplete: () => { selectedGift.photo.visible = false; }});
                selectedGift.boxModel.visible = true;
                gsap.to(selectedGift.boxModel.scale, {x:1, y:1, z:1, duration: 0.6, ease: "elastic.out(1, 0.5)", delay: 0.2});
                selectedGift.isOpen = false;
            } else {
                gsap.to(selectedGift.boxModel.scale, {x:0, y:0, z:0, duration: 0.4, ease: "back.in(1.7)", onComplete: () => { selectedGift.boxModel.visible = false; }});
                selectedGift.photo.visible = true;
                gsap.fromTo(selectedGift.photo.scale, {x:0,y:0,z:0}, {x:2.0, y:2.0, z:2.0, duration: 0.8, ease: "elastic.out(1, 0.5)", delay: 0.3});
                selectedGift.isOpen = true;
            }
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [], pExplode = [], pTree = [], pHeart = [], sizes = [], phases = [];
            
            for(let i=0; i<count; i++) {
                const pct = i / count;
                const h = pct * CONFIG.treeHeight;
                const ty = h - CONFIG.treeHeight / 2;
                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                let tx, tz, theta;
                if (type === 'gold') { 
                    const spirals = 15; 
                    theta = pct * Math.PI * 2 * spirals + Math.random()*0.5;
                    const r = maxR * (0.8 + Math.random()*0.2);
                    tx = r*Math.cos(theta); tz = r*Math.sin(theta);
                } else { 
                    theta = Math.random()*Math.PI*2;
                    const r = maxR * 0.9;
                    tx = r*Math.cos(theta); tz = r*Math.sin(theta);
                }
                pTree.push(tx, ty, tz);

                const u=Math.random(), v=Math.random(); 
                const phi=Math.acos(2*v-1), lam=2*Math.PI*u;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
                pExplode.push(rad*Math.sin(phi)*Math.cos(lam), rad*Math.sin(phi)*Math.sin(lam), rad*Math.cos(phi));

                // HEART SHAPE
                const tHeart = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tHeart), 3);
                let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
                const rFill = Math.pow(Math.random(), 0.3);
                hx *= rFill; hy *= rFill;
                let hz = (Math.random() - 0.5) * 8 * rFill;
                const scaleH = 2.0;
                // CH√ö √ù: +5 ·ªü ƒë√¢y l√† l√Ω do tr√°i tim b·ªã ƒë·∫©y l√™n cao
                pHeart.push(hx * scaleH, hy * scaleH + 5, hz);

                pPositions.push(tx, ty, tz); 
                sizes.push(size); 
                phases.push(Math.random()*Math.PI*2);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const colors = new Float32Array(count * 3);
            for(let i=0; i<count; i++) { 
                const variation = Math.random() * 0.4; 
                let baseColor;
                if (type === 'gold') {
                    baseColor = (i % 2 === 0) ? treeColor1 : treeColor2;
                    colors[i*3]     = Math.max(0, baseColor.r - variation*0.5);
                    colors[i*3+1]   = Math.min(1, baseColor.g + variation);
                    colors[i*3+2]   = Math.max(0, baseColor.b - variation*0.5);
                } else {
                    if(type === 'red') baseColor = new THREE.Color(0xFF0000);
                    else baseColor = new THREE.Color(0xFFFFFF);
                    colors[i*3]     = Math.min(1, baseColor.r + variation);
                    colors[i*3+1]   = Math.min(1, baseColor.g + variation);
                    colors[i*3+2]   = Math.min(1, baseColor.b + variation);
                }
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.userData = { tree: pTree, explode: pExplode, heart: pHeart, phases: phases, baseSize: size };
            
            const mat = new THREE.PointsMaterial({ 
                size: size, map: textures[type], transparent: true, opacity: 1.0, 
                vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true 
            });
            const points = new THREE.Points(geo, mat);
            mainGroup.add(points);
            return points;
        }

        function createSnow() {
            const positions = [], velocities = [];
            for(let i=0; i<CONFIG.snowCount; i++) {
                positions.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
                velocities.push((Math.random()-0.5)*0.2, -Math.random()*0.5 - 0.2, (Math.random()-0.5)*0.2);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.userData = { velocities: velocities };
            const mat = new THREE.PointsMaterial({ size: 1.5, map: textures['snow'], transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite:false });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function createDecorations() {
            // Text: Merry Christmas
            const tCanvasTree = document.createElement('canvas'); tCanvasTree.width=1024; tCanvasTree.height=256;
            const tCtxTree = tCanvasTree.getContext('2d');
            tCtxTree.font = 'bold italic 90px "Times New Roman"'; tCtxTree.fillStyle = '#FFD700'; tCtxTree.textAlign = 'center'; tCtxTree.shadowColor = "#FF4500"; tCtxTree.shadowBlur = 40;
            tCtxTree.fillText("MERRY CHRISTMAS", 512, 130);
            titleMeshTree = new THREE.Mesh(new THREE.PlaneGeometry(80, 20), new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(tCanvasTree), transparent:true, blending:THREE.AdditiveBlending, depthTest: false})); 
            titleMeshTree.position.set(0, CONFIG.treeHeight/2 + 10, 5); 
            titleMeshTree.renderOrder = 1; 
            mainGroup.add(titleMeshTree);

            // Gallery Text
            const tCanvasGallery = document.createElement('canvas'); tCanvasGallery.width=1024; tCanvasGallery.height=256;
            const tCtxGallery = tCanvasGallery.getContext('2d');
            tCtxGallery.font = 'bold italic 90px "Times New Roman"'; tCtxGallery.fillStyle = '#FFD700'; tCtxGallery.textAlign = 'center'; tCtxGallery.shadowColor = "#FF4500"; tCtxGallery.shadowBlur = 40;
            tCtxGallery.fillText("MERRY CHRISTMAS", 512, 130);
            titleMeshGallery = new THREE.Mesh(new THREE.PlaneGeometry(100, 25), new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(tCanvasGallery), transparent:true, blending:THREE.AdditiveBlending, depthTest: false})); 
            titleMeshGallery.position.set(0, CONFIG.explodeRadius + 10, 10); 
            titleMeshGallery.visible = false; 
            titleMeshGallery.renderOrder = 1;
            mainGroup.add(titleMeshGallery);

            // Star
            const sCanvas = document.createElement('canvas'); sCanvas.width=128; sCanvas.height=128;
            const sCtx = sCanvas.getContext('2d');
            sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor="#FFF"; sCtx.shadowBlur=20;
            sCtx.beginPath();
            const cx=64, cy=64, out=50, inn=20;
            for(let i=0; i<5; i++){ sCtx.lineTo(cx+Math.cos((18+i*72)/180*Math.PI)*out, cy-Math.sin((18+i*72)/180*Math.PI)*out); sCtx.lineTo(cx+Math.cos((54+i*72)/180*Math.PI)*inn, cy-Math.sin((54+i*72)/180*Math.PI)*inn); }
            sCtx.closePath(); sCtx.fill();
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(sCanvas), transparent:true, blending:THREE.AdditiveBlending, depthTest: false})); 
            starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 5); 
            starMesh.renderOrder = 1;
            mainGroup.add(starMesh);

            // Text: I LOVE YOU
            const loveCanvas = document.createElement('canvas'); loveCanvas.width = 1024; loveCanvas.height = 256;
            const lCtx = loveCanvas.getContext('2d');
            lCtx.font = 'bold 120px "Segoe UI", sans-serif'; lCtx.fillStyle = '#FFFFFF'; lCtx.textAlign = 'center';
            lCtx.shadowColor = "#FF1493"; lCtx.shadowBlur = 40;
            lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 542, 130);
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({
                map:new THREE.CanvasTexture(loveCanvas), 
                transparent:true, 
                blending:THREE.AdditiveBlending, 
                depthTest: false,
                color: heartColor
            }));
            // ƒê√É S·ª¨A: ƒê·∫∑t Y = 5 ƒë·ªÉ cƒÉn gi·ªØa v·ªõi tr√°i tim
            loveMesh.position.set(0, 5, 20); 
            loveMesh.visible = false; loveMesh.renderOrder = 2;
            mainGroup.add(loveMesh);
        }

        // --- CORE ANIMATION LOGIC ---
        function updateParticleGroup(group, type, targetState, speed, time) {
            const positions = group.geometry.attributes.position.array;
            const colors = group.geometry.attributes.color.array; // L·∫•y m·∫£ng m√†u

            let targetKey = 'tree';
            if (targetState === 'GALLERY') targetKey = 'explode';
            else if (targetState === 'HEART') targetKey = 'heart';
            
            const targets = group.geometry.userData[targetKey];

            for(let i=0; i<positions.length; i++) { positions[i] += (targets[i] - positions[i]) * speed; }
            group.geometry.attributes.position.needsUpdate = true;
            
            // X·ª≠ l√Ω logic t·ª´ng tr·∫°ng th√°i
            if (targetState === 'TREE') {
                group.rotation.y += 0.003;
                
                // Tr·∫£ l·∫°i m√†u c√¢y th√¥ng (2 m√†u) n·∫øu l√† nh√≥m Gold
                if (type === 'gold') {
                    for(let i=0; i<positions.length/3; i++) {
                        let baseC = (i % 2 === 0) ? treeColor1 : treeColor2;
                        colors[i*3] = baseC.r; colors[i*3+1] = baseC.g; colors[i*3+2] = baseC.b;
                    }
                    group.geometry.attributes.color.needsUpdate = true;
                }

            } else if (targetState === 'HEART') {
                 group.rotation.y = 0;
                 const beat = 1 + Math.abs(Math.sin(time * 3)) * 0.05;
                 group.scale.set(beat, beat, beat);
                 
                 // ƒê·ªïi to√†n b·ªô sang m√†u Tr√°i tim
                 for(let i=0; i<positions.length/3; i++) {
                     colors[i*3] = heartColor.r; colors[i*3+1] = heartColor.g; colors[i*3+2] = heartColor.b;
                 }
                 group.geometry.attributes.color.needsUpdate = true;

            } else {
                 group.scale.set(1, 1, 1);
            }
        }

        function updateSnow() {
            if(!snowSystem) return;
            const pos = snowSystem.geometry.attributes.position.array;
            const vel = snowSystem.geometry.userData.velocities;
            for(let i=0; i<CONFIG.snowCount; i++) {
                pos[i*3]+=vel[i*3]; pos[i*3+1]+=vel[i*3+1]; pos[i*3+2]+=vel[i*3+2];
                if (pos[i*3+1] < -100) { pos[i*3]=(Math.random()-0.5)*200; pos[i*3+1]=100; pos[i*3+2]=(Math.random()-0.5)*200; }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const speed = 0.08;

            updateSnow();
            updateParticleGroup(groupGold, 'gold', state, speed, time);
            updateParticleGroup(groupRed, 'red', state, speed, time);
            updateParticleGroup(groupGift, 'gift', state, speed, time);

            if (state === 'TREE') {
                mainGroup.rotation.y += (0 - mainGroup.rotation.y) * 0.05;
                giftObjects.forEach(obj => { obj.group.visible = false; });
                titleMeshTree.visible = true; starMesh.visible = true; titleMeshGallery.visible = false; loveMesh.visible = false;

            } else if (state === 'HEART') {
                mainGroup.rotation.y += (0 - mainGroup.rotation.y) * 0.05;
                giftObjects.forEach(obj => { obj.group.visible = false; });
                titleMeshTree.visible = false; starMesh.visible = false; titleMeshGallery.visible = false; loveMesh.visible = true;
                
                const s = 1 + Math.abs(Math.sin(time*3))*0.1;
                loveMesh.scale.set(s,s,1);

            } else { 
                // GALLERY
                mainGroup.rotation.y += (currentRotY - mainGroup.rotation.y) * 0.08;
                titleMeshTree.visible = false; starMesh.visible = false; titleMeshGallery.visible = true; loveMesh.visible = false;
                titleMeshGallery.lookAt(camera.position);

                let bestIdx = 0; let maxZ = -999;
                
                const totalGifts = giftObjects.length;
                if(totalGifts > 0) {
                    giftObjects.forEach((obj, i) => {
                        obj.group.visible = true;
                        const ang = i * (Math.PI * 2 / totalGifts); 
                        
                        const tx = Math.sin(ang) * CONFIG.photoOrbitRadius;
                        const tz = Math.cos(ang) * CONFIG.photoOrbitRadius;
                        const ty = Math.sin(time + i) * 5 + obj.randomY;
                        
                        obj.group.position.lerp(new THREE.Vector3(tx, ty, tz), 0.1);
                        
                        if(obj.isOpen) { 
                            obj.group.lookAt(camera.position); 
                            const flash = (Math.sin(time*10)+1)/2;
                            obj.border.material.color.setHSL(0.14, 1, 0.5+flash*0.5);
                        } else { 
                            obj.group.lookAt(camera.position);
                            obj.group.rotation.x += Math.sin(time+i)*0.03; 
                            obj.group.rotation.z += Math.cos(time+i)*0.03; 
                        }

                        const worldPos = new THREE.Vector3();
                        obj.group.getWorldPosition(worldPos);
                        if(worldPos.z > maxZ) { maxZ = worldPos.z; bestIdx = i; }
                    });
                    selectedIndex = bestIdx;
                }
            }
            renderer.render(scene, camera);
        }

        let lastVideoTime = -1; 
        async function initAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions:{
                        modelAssetPath:`https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, 
                        delegate:"GPU" 
                    },
                    runningMode:"VIDEO", numHands: 2
                });
                videoElement = document.getElementById('input-video');
                const stream = await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1920}, height:{ideal:1080}}, audio:false});
                videoElement.srcObject = stream;
                
                const vidTex = new THREE.VideoTexture(videoElement);
                vidTex.colorSpace = THREE.SRGBColorSpace;
                if(camPreviewMesh) { camPreviewMesh.material.map = vidTex; camPreviewMesh.material.needsUpdate = true; }

                videoElement.addEventListener("loadeddata",()=>{document.getElementById('loader').style.display='none'; predictLoop();});
            } catch(e){console.error(e);}
        }

        function predictLoop() {
            if(videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                
                const res = handLandmarker.detectForVideo(videoElement, performance.now());
                
                // LOGIC PH√ÅT HI·ªÜN TIM (2 TAY)
                if (res.landmarks.length === 2) {
                    const h1 = res.landmarks[0]; const h2 = res.landmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    
                    if (distIndex < 0.15 && distThumb < 0.15) {
                        state = 'HEART';
                        requestAnimationFrame(predictLoop);
                        return;
                    }
                }

                // LOGIC 1 TAY (C≈®)
                if (res.landmarks.length > 0) {
                    const lm = res.landmarks[0];
                    handX = lm[9].x; 

                    const tips=[8,12,16,20]; let openDist=0;
                    tips.forEach(i=>openDist+=Math.hypot(lm[i].x-lm[0].x, lm[i].y-lm[0].y));
                    const avgDist = openDist/4;
                    const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

                    if (avgDist < 0.25) { 
                        state = 'TREE'; 
                    } 
                    else if (pinchDist < 0.05) { 
                        if (Date.now() - lastPinchTime > 1000) { 
                            toggleGift(); 
                            lastPinchTime = Date.now(); 
                        }
                    } 
                    else { 
                        state = 'GALLERY'; 
                        let deltaX = lastHandX - handX; 
                        if (deltaX < 0) deltaX = 0; 
                        currentRotY += deltaX * 12;
                    }
                    lastHandX = handX;
                }
            }
            requestAnimationFrame(predictLoop);
        }

        initThree(); initAI(); animate();
    </script>
