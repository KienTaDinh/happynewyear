<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Gallery (Default & Upload)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; width: 95%; }
        
        /* H·ªôp h∆∞·ªõng d·∫´n */
        .guide-box {
            background: rgba(5, 15, 30, 0.85); border: 1px solid #ffd700;
            color: #fff; padding: 20px; border-radius: 12px; width: 300px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(10px);
            margin-bottom: 10px;
        }
        .guide-box h3 { margin: 0 0 15px 0; color: #ffd700; font-size: 16px; text-transform: uppercase; letter-spacing: 1px;}
        .guide-box li { margin-bottom: 10px; font-size: 14px; color: #ccc; list-style: none; display: flex; align-items: center;}
        .icon { width: 25px; display: inline-block; text-align: center; margin-right: 10px; }

        /* Control Panel */
        .control-panel {
            pointer-events: auto; 
            background: rgba(30, 10, 10, 0.9); border: 1px solid #ff4444;
            color: #fff; padding: 20px; border-radius: 12px; width: 300px;
            backdrop-filter: blur(10px);
            display: block; 
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; color: #ff8888; font-size: 12px; margin-bottom: 5px; text-transform: uppercase;}
        input[type="file"] { width: 100%; color: #fff; font-size: 12px; }

        #btn-confirm {
            width: 100%; padding: 10px; margin-top: 10px;
            background: linear-gradient(90deg, #b22222, #ff4444);
            border: none; border-radius: 6px;
            color: white; font-weight: bold; cursor: pointer;
            text-transform: uppercase; letter-spacing: 1px;
        }
        #btn-confirm:hover { filter: brightness(1.2); }

        /* N√∫t Quay Phim */
        #btn-record {
            pointer-events: auto;
            display: none; 
            margin-top: 10px;
            background: rgba(255, 0, 0, 0.2); border: 1px solid #ff0000;
            color: #ff0000; padding: 10px 20px; border-radius: 8px;
            cursor: pointer; font-weight: bold; width: 300px;
            transition: 0.3s;
        }
        #btn-record.recording {
            background: #ff0000; color: white; box-shadow: 0 0 20px red;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.02);} 100% {transform: scale(1);} }

        #btn-settings {
            pointer-events: auto;
            position: absolute; top: 0; right: 0;
            background: rgba(255, 215, 0, 0.1); border: 1px solid #ffd700;
            color: #ffd700; padding: 10px 20px; border-radius: 8px;
            cursor: pointer; font-weight: bold;
            display: none; 
            backdrop-filter: blur(5px);
        }

        /* Camera Preview nh·ªè */
        #cam-preview {
            position: absolute; bottom: 30px; left: 30px;
            width: 100px; height: 75px; 
            border: 1px solid #444; border-radius: 8px;
            background: #000; overflow: hidden; z-index: 10; opacity: 0.5;
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        #status-text {
            position: absolute; bottom: 120px; left: 30px;
            color: #ffd700; font-family: 'Courier New', monospace; 
            font-weight: bold; font-size: 14px; text-shadow: 0 0 5px #ffd700;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020202; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 999;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid #222;
            border-top: 4px solid #d4af37; border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        #photo-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 1000;
            justify-content: center; align-items: center; flex-direction: column;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from {opacity:0} to {opacity:1} }
        #photo-modal img {
            max-width: 85%; max-height: 85%; border: 1px solid #555;
            box-shadow: 0 0 50px rgba(255,215,0,0.3); border-radius: 4px;
        }
        #photo-modal p { color: #888; margin-top: 15px; font-size: 14px; letter-spacing: 2px; }

        canvas {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain;
            display: block;
        }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="color: #666; font-size: 12px; letter-spacing: 3px;">LOADING RESOURCES...</div>
    </div>

    <div id="ui-layer">
        <button id="btn-settings">‚öôÔ∏è C√ÄI ƒê·∫∂T</button>

        <div class="guide-box">
            <h3>Studio Quay Phim (FHD)</h3>
            <ul>
                <li><span class="icon">‚úä</span> <b>N·∫Øm tay:</b> C√¢y Th√¥ng.</li>
                <li><span class="icon">‚úã</span> <b>M·ªü tay:</b> Qu·∫£ C·∫ßu.</li>
                <li><span class="icon">‚è∫Ô∏è</span> <b>REC:</b> B·∫•m Confirm ƒë·ªÉ b·∫≠t nh·∫°c.</li>
            </ul>
            <button id="btn-record">‚è∫Ô∏è B·∫ÆT ƒê·∫¶U QUAY</button>
        </div>

        <div class="control-panel" id="main-panel">
            <div class="control-group">
                <label>1. Nh·∫°c n·ªÅn (ƒê√£ c√≥ m·∫∑c ƒë·ªãnh)</label>
                <input type="file" id="music-input" accept="audio/*">
            </div>
            <div class="control-group">
                <label>2. Upload ·∫¢nh (ƒê√£ c√≥ m·∫∑c ƒë·ªãnh)</label>
                <input type="file" id="photo-input" accept="image/*" multiple>
            </div>
            <button id="btn-confirm">‚úÖ X√ÅC NH·∫¨N & PH√ÅT NH·∫†C</button>
        </div>
    </div>

    <div id="status-text">SYSTEM STANDBY...</div>
    <div id="cam-preview" style="opacity:0; pointer-events:none;"><video id="input-video" autoplay playsinline muted></video></div>
    <div id="photo-modal"><img id="modal-img" src=""><p>[ CH·ª§M TAY ƒê·ªÇ ƒê√ìNG ]</p></div>
    
    <audio id="bg-music" loop crossorigin="anonymous"></audio>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0';

        const panel = document.getElementById('main-panel');
        const btnConfirm = document.getElementById('btn-confirm');
        const btnSettings = document.getElementById('btn-settings');
        const btnRecord = document.getElementById('btn-record');
        const audioEl = document.getElementById('bg-music');

        // --- C·∫§U H√åNH M·∫∂C ƒê·ªäNH (S·ª¨A T√äN FILE ·ªû ƒê√ÇY N·∫æU C·∫¶N) ---
        // L∆∞u √Ω: C√°c file n√†y ph·∫£i n·∫±m c√πng th∆∞ m·ª•c v·ªõi file HTML
        const DEFAULT_MUSIC_PATH = './music.mp3';
        
        let PHOTOS = [
            { url: './image1.jpg' },
            { url: './image2.jpg' },
            { url: './image3.jpg' }
        ];

        // Load nh·∫°c m·∫∑c ƒë·ªãnh ngay khi m·ªü
        audioEl.src = DEFAULT_MUSIC_PATH;

        let isRecording = false;
        let mediaRecorder;
        let recordedChunks = [];
        let audioContext;
        let destNode;
        let sourceNode;
        let isAudioSetup = false;

        btnConfirm.addEventListener('click', () => {
            panel.style.display = 'none';
            btnSettings.style.display = 'block';
            btnRecord.style.display = 'block';
            
            // Kh·ªüi t·∫°o AudioContext
            initAudioContext();
            
            // K√≠ch ho·∫°t ph√°t nh·∫°c (do tr√¨nh duy·ªát ch·∫∑n autoplay)
            if (audioEl.paused) {
                audioEl.play().then(() => {
                    console.log("Playing default/uploaded music");
                    connectAudioSource();
                }).catch(e => console.log("Audio waiting for user interaction"));
            }
        });

        btnSettings.addEventListener('click', () => {
            panel.style.display = 'block';
            btnSettings.style.display = 'none';
            btnRecord.style.display = 'none';
        });

        // --- X·ª¨ L√ù UPLOAD THAY TH·∫æ M·∫∂C ƒê·ªäNH ---
        
        // 1. Upload Nh·∫°c
        document.getElementById('music-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                // Thay th·∫ø link nh·∫°c m·∫∑c ƒë·ªãnh b·∫±ng link file v·ª´a upload
                audioEl.src = URL.createObjectURL(file);
                audioEl.play().then(() => {
                    if(audioContext) connectAudioSource();
                }).catch(e => console.error("Play error:", e));
            }
        });

        // 2. Upload ·∫¢nh
        document.getElementById('photo-input').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                // X√≥a danh s√°ch ·∫£nh m·∫∑c ƒë·ªãnh, thay b·∫±ng ·∫£nh m·ªõi
                PHOTOS = files.map(file => ({ url: URL.createObjectURL(file) }));
                updatePhotoMarkers(); 
                document.getElementById('status-text').innerText = `UPDATED ${files.length} PHOTOS`;
            }
        });

        // --- H·ªÜ TH·ªêNG √ÇM THANH ---
        function initAudioContext() {
            if (isAudioSetup) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                destNode = audioContext.createMediaStreamDestination();
                isAudioSetup = true;
            } catch (e) { console.error("Audio Context Error:", e); }
        }

        function connectAudioSource() {
            if (!audioContext || !audioEl.src) return;
            if (sourceNode) { sourceNode.disconnect(); }
            try {
                sourceNode = audioContext.createMediaElementSource(audioEl);
                sourceNode.connect(destNode); 
                sourceNode.connect(audioContext.destination); 
            } catch(e) { console.log("Connection warning:", e); }
        }

        // --- QUAY PHIM 1080P ---
        btnRecord.addEventListener('click', async () => {
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        function startRecording() {
            const canvas = document.querySelector('canvas');
            if (!canvas) return;
            const canvasStream = canvas.captureStream(30);
            const finalStream = new MediaStream();
            canvasStream.getVideoTracks().forEach(track => finalStream.addTrack(track));
            
            if (destNode && destNode.stream.getAudioTracks().length > 0) {
                destNode.stream.getAudioTracks().forEach(track => finalStream.addTrack(track));
            }

            recordedChunks = [];
            const options = {
                mimeType: 'video/webm; codecs=vp9',
                videoBitsPerSecond: 5000000, 
                audioBitsPerSecond: 128000   
            };

            try {
                mediaRecorder = new MediaRecorder(finalStream, options);
            } catch (e) {
                mediaRecorder = new MediaRecorder(finalStream);
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) recordedChunks.push(event.data);
            };

            mediaRecorder.onstop = saveVideo;
            mediaRecorder.start();
            isRecording = true;
            btnRecord.innerText = "‚èπÔ∏è D·ª™NG & L∆ØU";
            btnRecord.classList.add('recording');
        }

        function stopRecording() {
            mediaRecorder.stop();
            isRecording = false;
            btnRecord.innerText = "‚è∫Ô∏è B·∫ÆT ƒê·∫¶U QUAY";
            btnRecord.classList.remove('recording');
        }

        function saveVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `smart-gallery-${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }

        // --- 3D SETUP ---
        const CORE_COUNT = 6000;
        const HALO_COUNT = 2000;
        const TOTAL_COUNT = CORE_COUNT + HALO_COUNT;

        let scene, camera, renderer, particleSystem, mainGroup;
        let spherePos = [], treePos = [];
        let handLandmarker, videoElement;
        
        let isTreeMode = false;
        let currentRotX = 0, currentRotY = 0; 
        let lastHandX = 0.5, lastHandY = 0.5; 
        let lastPinchTime = 0;
        let isModalOpen = false;
        let decoratedTreeGroup;
// Th√™m bi·∫øn to√†n c·ª•c cho Modal 3D ·ªü ƒë·∫ßu script c√πng c√°c bi·∫øn kh√°c
let modalMesh; 

function initThree() {
    scene = new THREE.Scene();
    
    const WIDTH = 1920;
    const HEIGHT = 1080;
    const ASPECT = WIDTH / HEIGHT;

    camera = new THREE.PerspectiveCamera(75, ASPECT, 0.1, 1000);
    
    // --- S·ª¨A 1: ƒê∆∞a Camera v·ªÅ y = 0 ƒë·ªÉ nh√¨n th·∫≥ng v√†o t√¢m c√¢y (C√¢y s·∫Ω ra gi·ªØa m√†n h√¨nh) ---
    camera.position.set(0, 0, 25); 

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setSize(WIDTH, HEIGHT, false); 
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- S·ª¨A 2: T·∫°o Modal 3D (ƒë·ªÉ quay phim ƒë∆∞·ª£c) ---
    // T·∫°o m·ªôt t·∫•m b·∫£ng ƒëen m·ªù l√†m n·ªÅn
    const bgGeo = new THREE.PlaneGeometry(20, 15);
    const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.9 });
    const modalBg = new THREE.Mesh(bgGeo, bgMat);
    modalBg.position.z = -0.1; // N·∫±m sau ·∫£nh m·ªôt ch√∫t

    // T·∫°o t·∫•m b·∫£ng hi·ªÉn th·ªã ·∫£nh
    const imgGeo = new THREE.PlaneGeometry(16, 9); // T·ªâ l·ªá 16:9
    const imgMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // M·∫∑c ƒë·ªãnh tr·∫Øng, s·∫Ω thay texture sau
    const modalImg = new THREE.Mesh(imgGeo, imgMat);
    modalImg.name = "modalImage"; // ƒê·∫∑t t√™n ƒë·ªÉ d·ªÖ t√¨m

    modalMesh = new THREE.Group();
    modalMesh.add(modalBg);
    modalMesh.add(modalImg);
    
    // G·∫Øn Modal v√†o Camera ƒë·ªÉ n√≥ lu√¥n "bay" tr∆∞·ªõc m·∫∑t ng∆∞·ªùi xem (HUD)
    modalMesh.position.set(0, 0, -15); // C√°ch m·∫∑t camera 15 ƒë∆°n v·ªã
    modalMesh.visible = false; // M·∫∑c ƒë·ªãnh ·∫©n
    camera.add(modalMesh); // Quan tr·ªçng: Add v√†o Camera ch·ª© kh√¥ng ph·∫£i Scene
    scene.add(camera);     // Add camera v√†o scene ƒë·ªÉ modal hi·ªán ra

    // ... (Gi·ªØ nguy√™n ph·∫ßn √°nh s√°ng Light nh∆∞ c≈©) ...
    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);
    const spotLight = new THREE.SpotLight(0xffaa33, 1.5);
    spotLight.position.set(10, 20, 20);
    spotLight.castShadow = true;
    scene.add(spotLight);
    const pointLight = new THREE.PointLight(0xff0000, 0.5);
    pointLight.position.set(-10, 10, 10);
    scene.add(pointLight);

    mainGroup = new THREE.Group();
    scene.add(mainGroup);

    // ... (Gi·ªØ nguy√™n ph·∫ßn t·∫°o Particles, Tree, Garland, Box nh∆∞ code c≈©) ...
    // Copy l·∫°i ƒëo·∫°n v√≤ng l·∫∑p t·∫°o spherePos, decoratedTreeGroup t·ª´ code c≈© v√†o ƒë√¢y
    // V√å CODE KH√îNG ƒê·ªîI N√äN T√îI L∆Ø·ª¢C B·ªöT ƒê·ªÇ B·∫†N D·ªÑ NH√åN
    // Ch·ªâ c·∫ßn ƒë·∫£m b·∫£o mainGroup ƒë√£ ƒë∆∞·ª£c add c√°c v·∫≠t th·ªÉ.
    
    // G·ªçi t·∫°o Particles
    spherePos = new Float32Array(TOTAL_COUNT * 3);
    for(let i=0; i<TOTAL_COUNT; i++) {
        // ... (Logic t·∫°o h·∫°t gi·ªØ nguy√™n) ...
        const isCore = i < CORE_COUNT;
        let r = isCore ? (10 + Math.random() * 2) : (15 + Math.random() * 8);
        let theta = Math.random() * Math.PI * 2;
        let phi = Math.acos(2 * Math.random() - 1);
        spherePos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        spherePos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        spherePos[i*3+2] = r * Math.cos(phi);
    }
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(spherePos, 3));
    const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.15, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
    particleSystem = new THREE.Points(geometry, material);
    mainGroup.add(particleSystem);

    // G·ªçi t·∫°o C√¢y (DecoratedTreeGroup) - (Gi·ªØ nguy√™n logic c≈©)
    decoratedTreeGroup = new THREE.Group();
    mainGroup.add(decoratedTreeGroup);
    decoratedTreeGroup.visible = false;
    // ... (Copy l·∫°i ƒëo·∫°n t·∫°o c√¢y, ƒë√®n, qu√† t·ª´ code c≈©) ...
    // ƒê·ªÉ ti·∫øt ki·ªám ch·ªó hi·ªÉn th·ªã t√¥i kh√¥ng paste l·∫°i ƒëo·∫°n t·∫°o c√¢y d√†i d√≤ng, b·∫°n gi·ªØ nguy√™n nh√©.

    // T·∫°o Tuy·∫øt (Gi·ªØ nguy√™n)
    treePos = new Float32Array(HALO_COUNT * 3);
    for (let i = 0; i < HALO_COUNT; i++) {
        treePos[i*3] = (Math.random() - 0.5) * 40;
        treePos[i*3+1] = (Math.random() - 0.5) * 45;
        treePos[i*3+2] = (Math.random() - 0.5) * 40;
    }

    updatePhotoMarkers();
}

        function updatePhotoMarkers() {
            for (let i = mainGroup.children.length - 1; i >= 0; i--) {
                const child = mainGroup.children[i];
                if (child.userData && child.userData.isPhotoMarker) mainGroup.remove(child);
            }
            const markerGeo = new THREE.PlaneGeometry(3, 2); 
            const count = PHOTOS.length;
            const phi = Math.PI * (3 - Math.sqrt(5)); 
            for (let i = 0; i < count; i++) {
                const y = (1 - (i / (count - 1 + 0.0001)) * 2) * 6; 
                const radiusAtY = Math.sqrt(12.5*12.5 - y*y); 
                const theta = phi * i * 5; 
                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;
                const texture = new THREE.TextureLoader().load(PHOTOS[i].url);
                const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(markerGeo, mat);
                mesh.position.set(x, y, z);
                mesh.lookAt(0, y, 0);
                mesh.userData = { url: PHOTOS[i].url, isPhotoMarker: true };
                if(isTreeMode) mesh.visible = false;
                mainGroup.add(mesh);
            }
        }

      async function initAI() {
    try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
        });
        videoElement = document.getElementById('input-video');
        
        // --- S·ª¨A 3: Y√™u c·∫ßu ƒë·ªô ph√¢n gi·∫£i cao (1080p) ---
        const constraints = {
            video: {
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                frameRate: { ideal: 30 }
            },
            audio: false
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = stream;
        
        const videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.colorSpace = THREE.SRGBColorSpace; // Th√™m d√≤ng n√†y cho m√†u t∆∞∆°i h∆°n
        scene.background = videoTexture;

        videoElement.addEventListener("loadeddata", () => {
            document.getElementById('loader').style.display = 'none';
            predictLoop();
        });
    } catch(e) { console.error(e); }
}

        function checkFist(lm) {
            const palmSize = Math.sqrt(Math.pow(lm[0].x - lm[9].x, 2) + Math.pow(lm[0].y - lm[9].y, 2));
            const distMiddle = Math.sqrt(Math.pow(lm[0].x - lm[12].x, 2) + Math.pow(lm[0].y - lm[12].y, 2));
            const distRing   = Math.sqrt(Math.pow(lm[0].x - lm[16].x, 2) + Math.pow(lm[0].y - lm[16].y, 2));
            return (distMiddle < palmSize * 1.2) && (distRing < palmSize * 1.2);
        }

        function predictLoop() {
            if (videoElement.currentTime !== lastPinchTime) {
                const result = handLandmarker.detectForVideo(videoElement, performance.now());
                const statusEl = document.getElementById('status-text');

                if (result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    const isFist = checkFist(lm);

                    if(isFist) {
                        if(!isTreeMode) {
                            isTreeMode = true;
                            mainGroup.rotation.x = 0; mainGroup.rotation.z = 0; currentRotX = 0;
                            particleSystem.visible = false;
                            decoratedTreeGroup.visible = true;
                            mainGroup.children.forEach(c => { if(c.userData.isPhotoMarker) c.visible = false; });
                            if (!scene.getObjectByName("snowSystem")) {
                                const snowGeo = new THREE.BufferGeometry();
                                snowGeo.setAttribute('position', new THREE.BufferAttribute(treePos, 3));
                                const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true });
                                const snowSystem = new THREE.Points(snowGeo, snowMat);
                                snowSystem.name = "snowSystem";
                                mainGroup.add(snowSystem);
                            } else { scene.getObjectByName("snowSystem").visible = true; }
                        }
                        statusEl.innerHTML = "üéÑ CHRISTMAS TREE";
                        lastHandX = lm[9].x; lastHandY = lm[9].y;
                    } else {
                        if(isTreeMode) {
                            isTreeMode = false;
                            currentRotX = 0; mainGroup.rotation.x = 0;
                            particleSystem.visible = true;
                            decoratedTreeGroup.visible = false;
                            mainGroup.children.forEach(c => { if(c.userData.isPhotoMarker) c.visible = true; });
                            if (scene.getObjectByName("snowSystem")) scene.getObjectByName("snowSystem").visible = false;
                        }
                        statusEl.innerHTML = "üîÆ GALLERY CONTROL";
                        const currentX = lm[9].x; 
                        let deltaX = lastHandX - currentX; 
                        if (Math.abs(deltaX) < 0.003) deltaX = 0;
                        if (deltaX < 0) deltaX = 0; 
                        currentRotY += deltaX * 8;
                        lastHandX = currentX; lastHandY = lm[9].y;
                        const pinchDist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                        if(pinchDist < 0.05 && Date.now() - lastPinchTime > 1000) {
                            toggleModal();
                            lastPinchTime = Date.now();
                        }
                    }
                }
            }
            requestAnimationFrame(predictLoop);
        }

        function toggleModal() {
    // N·∫øu ƒëang m·ªü th√¨ ƒë√≥ng l·∫°i
    if(isModalOpen) {
        // ·∫®n b·∫£ng 3D
        if(modalMesh) modalMesh.visible = false;
        
        // ·∫®n c·∫£ th·∫ª HTML (ƒë·ªÉ d·ª± ph√≤ng)
        document.getElementById('photo-modal').style.display = 'none';
        
        isModalOpen = false;
    } else {
        // T√¨m ·∫£nh g·∫ßn nh·∫•t
        let closest = null; let maxZ = -999;
        mainGroup.children.forEach(child => {
            if(child.userData.isPhotoMarker && child.visible) {
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                // Gi·∫£m kho·∫£ng c√°ch k√≠ch ho·∫°t xu·ªëng > 2 (v√¨ camera ƒë√£ l√πi v·ªÅ)
                if(worldPos.z > maxZ) { maxZ = worldPos.z; closest = child; }
            }
        });

        // K√≠ch ho·∫°t n·∫øu ·∫£nh ·ªü ƒë·ªß g·∫ßn (maxZ > 2)
        if(closest && maxZ > 2) { 
            const url = closest.userData.url;

            // --- S·ª¨A 4: Hi·ªÉn th·ªã l√™n Modal 3D ---
            if(modalMesh) {
                const imgMesh = modalMesh.getObjectByName("modalImage");
                if(imgMesh) {
                    // Load texture ·∫£nh m·ªõi
                    const texture = new THREE.TextureLoader().load(url);
                    // Update texture cho t·∫•m b·∫£ng
                    imgMesh.material.map = texture;
                    imgMesh.material.needsUpdate = true;
                }
                modalMesh.visible = true; // Hi·ªán l√™n
            }

            isModalOpen = true;
        }
    }
}

        function animate() {
            requestAnimationFrame(animate);
            if (isTreeMode) {
                mainGroup.rotation.y -= 0.005;
                mainGroup.rotation.x = 0; 
                const snowSystem = scene.getObjectByName("snowSystem");
                if (snowSystem) {
                    snowSystem.rotation.y += 0.002;
                    const positions = snowSystem.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] -= 0.15; 
                        if (positions[i] < -25) positions[i] = 25;
                    }
                    snowSystem.geometry.attributes.position.needsUpdate = true;
                }
            } else {
                mainGroup.rotation.y += (currentRotY - mainGroup.rotation.y) * 0.08;
                mainGroup.rotation.x = 0; 
                mainGroup.children.forEach(child => {
                    if (child.userData.isPhotoMarker) child.lookAt(camera.position);
                });
            }
            particleSystem.rotation.y += 0.001; 
            renderer.render(scene, camera);
        }

        initThree();
        initAI();
        animate();
    </script>
</body>
</html>
