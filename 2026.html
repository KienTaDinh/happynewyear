    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Smart Gallery Gesture</title>
        <style>
            body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
            
            /* UI Layer */
            #ui-layer { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; width: 95%; }
            
            /* H·ªôp h∆∞·ªõng d·∫´n */
            .guide-box {
                background: rgba(5, 15, 30, 0.85); border: 1px solid #00ffff;
                color: #fff; padding: 20px; border-radius: 12px; width: 300px;
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
                backdrop-filter: blur(10px);
                margin-bottom: 10px;
            }
            .guide-box h3 { margin: 0 0 15px 0; color: #00ffff; font-size: 16px; text-transform: uppercase; letter-spacing: 1px;}
            .guide-box li { margin-bottom: 10px; font-size: 14px; color: #ccc; list-style: none; display: flex; align-items: center;}
            .icon { width: 25px; display: inline-block; text-align: center; margin-right: 10px; }

            /* Control Panel (Khung Upload) */
            .control-panel {
                pointer-events: auto; 
                background: rgba(20, 0, 0, 0.9); border: 1px solid #ff4444;
                color: #fff; padding: 20px; border-radius: 12px; width: 300px;
                backdrop-filter: blur(10px);
                transition: opacity 0.3s;
                display: block; /* M·∫∑c ƒë·ªãnh hi·ªán */
            }
            .control-group { margin-bottom: 15px; }
            .control-group label { display: block; color: #ff8888; font-size: 12px; margin-bottom: 5px; text-transform: uppercase;}
            input[type="file"] {
                width: 100%; color: #fff; font-size: 12px;
                file-selector-button {
                    background: #444; border: 1px solid #666; color: white; padding: 5px 10px;
                    border-radius: 4px; cursor: pointer; margin-right: 10px;
                }
                file-selector-button:hover { background: #666; }
            }

            /* N√∫t X√°c Nh·∫≠n (M·ªõi) */
            #btn-confirm {
                width: 100%; padding: 10px; margin-top: 10px;
                background: linear-gradient(90deg, #ff4444, #ff8800);
                border: none; border-radius: 6px;
                color: white; font-weight: bold; cursor: pointer;
                text-transform: uppercase; letter-spacing: 1px;
                box-shadow: 0 0 10px rgba(255, 68, 68, 0.4);
            }
            #btn-confirm:hover { filter: brightness(1.2); }

            /* N√∫t M·ªü L·∫°i C√†i ƒê·∫∑t (N√∫t Back) */
            #btn-settings {
                pointer-events: auto;
                position: absolute; top: 0; right: 0;
                background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff;
                color: #00ffff; padding: 10px 20px; border-radius: 8px;
                cursor: pointer; font-weight: bold;
                display: none; /* M·∫∑c ƒë·ªãnh ·∫©n, ch·ªâ hi·ªán khi ƒë√£ ·∫©n panel */
                backdrop-filter: blur(5px);
            }
            #btn-settings:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 15px #00ffff; }

            /* Camera Preview */
            #cam-preview {
                position: absolute; bottom: 30px; left: 30px;
                width: 160px; height: 120px;
                border: 2px solid #444; border-radius: 12px;
                background: #000; overflow: hidden; z-index: 10; opacity: 0.8;
                box-shadow: 0 5px 20px black;
            }
            #input-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

            /* Tr·∫°ng th√°i */
            #status-text {
                position: absolute; bottom: 170px; left: 30px;
                color: #00ff00; font-family: 'Courier New', monospace; 
                font-weight: bold; font-size: 14px; text-shadow: 0 0 5px #00ff00;
            }

            /* M√†n h√¨nh ch·ªù Loading */
            #loader {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #020202; display: flex; flex-direction: column;
                justify-content: center; align-items: center; z-index: 999;
            }
            .spinner {
                width: 50px; height: 50px; border: 4px solid #222;
                border-top: 4px solid #00ffff; border-radius: 50%;
                animation: spin 0.8s linear infinite; margin-bottom: 20px;
            }
            @keyframes spin { 100% { transform: rotate(360deg); } }

            /* Modal hi·ªÉn th·ªã ·∫£nh */
            #photo-modal {
                display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.95); z-index: 1000;
                justify-content: center; align-items: center; flex-direction: column;
                animation: fadeIn 0.3s;
            }
            @keyframes fadeIn { from {opacity:0} to {opacity:1} }
            #photo-modal img {
                max-width: 85%; max-height: 85%; border: 1px solid #555;
                box-shadow: 0 0 50px rgba(0,255,255,0.2); border-radius: 4px;
            }
            #photo-modal p { color: #888; margin-top: 15px; font-size: 14px; letter-spacing: 2px; }

        </style>
    </head>
    <body>

        <div id="loader">
            <div class="spinner"></div>
            <div style="color: #666; font-size: 12px; letter-spacing: 3px;">INITIALIZING SYSTEM...</div>
        </div>

        <div id="ui-layer">
            <button id="btn-settings">‚öôÔ∏è C√ÄI ƒê·∫∂T / UPLOAD</button>

            <div class="guide-box">
                <h3>H·ªá th·ªëng ƒêi·ªÅu khi·ªÉn</h3>
                <ul>
                    <li><span class="icon">‚úä</span> <b>N·∫Øm tay:</b> C√¢y Th√¥ng.</li>
                    <li><span class="icon">‚úã</span> <b>M·ªü tay:</b> Qu·∫£ C·∫ßu (Xoay ngang).</li>
                    <li><span class="icon">‚û°Ô∏è</span> <b>Vu·ªët Ph·∫£i:</b> Xem ·∫£nh k·∫ø ti·∫øp.</li>
                    <li><span class="icon">üëå</span> <b>Ch·ª•m tay:</b> M·ªü ·∫£nh.</li>
                </ul>
            </div>

            <div class="control-panel" id="main-panel">
                <div class="control-group">
                    <label>1. Nh·∫°c n·ªÅn (MP3)</label>
                    <input type="file" id="music-input" accept="audio/*">
                </div>
                <div class="control-group">
                    <label>2. Upload ·∫¢nh (Ch·ªçn nhi·ªÅu ·∫£nh)</label>
                    <input type="file" id="photo-input" accept="image/*" multiple>
                </div>
                <button id="btn-confirm">‚úÖ X√ÅC NH·∫¨N & ·∫®N</button>
            </div>
        </div>

        <div id="status-text">SYSTEM STANDBY...</div>
        <div id="cam-preview"><video id="input-video" autoplay playsinline></video></div>
        <div id="photo-modal"><img id="modal-img" src=""><p>[ CH·ª§M TAY ƒê·ªÇ ƒê√ìNG ]</p></div>
        <audio id="bg-music" loop></audio>

        <script type="module">
            import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
            import { FilesetResolver, HandLandmarker } from 'https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0';

            // --- X·ª¨ L√ù GIAO DI·ªÜN (·∫®N/HI·ªÜN PANEL) ---
            const panel = document.getElementById('main-panel');
            const btnConfirm = document.getElementById('btn-confirm');
            const btnSettings = document.getElementById('btn-settings');

            // B·∫•m X√°c Nh·∫≠n -> ·∫®n Panel -> Hi·ªán n√∫t Settings
            btnConfirm.addEventListener('click', () => {
                panel.style.display = 'none';
                btnSettings.style.display = 'block';
            });

            // B·∫•m Settings -> Hi·ªán Panel -> ·∫®n n√∫t Settings
            btnSettings.addEventListener('click', () => {
                panel.style.display = 'block';
                btnSettings.style.display = 'none';
            });
            // ----------------------------------------

            let PHOTOS = [
                { url: 'https://images.unsplash.com/photo-1534447677768-be436bb09401?w=600&q=80' },
                { url: 'https://images.unsplash.com/photo-1502472584285-f291a43934d0?w=600&q=80' }, 
                { url: 'https://images.unsplash.com/photo-1479660656269-197ebb83b540?w=600&q=80' },
                { url: 'https://images.unsplash.com/photo-1516724562728-afc824a36e84?w=600&q=80' },
                { url: 'https://images.unsplash.com/photo-1504280390367-361c6d9f38f4?w=600&q=80' }
            ];

            const CORE_COUNT = 5000;
            const HALO_COUNT = 2500;
            const TOTAL_COUNT = CORE_COUNT + HALO_COUNT;

            let scene, camera, renderer, particleSystem, mainGroup;
            let spherePos = [], treePos = [];
            let handLandmarker, videoElement;
            
            let isTreeMode = false;
            let currentRotX = 0, currentRotY = 0; 
            let lastHandX = 0.5, lastHandY = 0.5; 
            let lastPinchTime = 0;
            let isModalOpen = false;
            let decoratedTreeGroup;

            // X·ª≠ l√Ω Upload Media
            document.getElementById('music-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const audio = document.getElementById('bg-music');
                    audio.src = URL.createObjectURL(file);
                    audio.play();
                    document.getElementById('status-text').innerText = "üéµ PLAYING MUSIC...";
                }
            });

            document.getElementById('photo-input').addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    PHOTOS = files.map(file => ({ url: URL.createObjectURL(file) }));
                    updatePhotoMarkers(); 
                    document.getElementById('status-text').innerText = `‚úÖ LOADED ${files.length} PHOTOS`;
                }
            });

            function initThree() {
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.015);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 28;

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);

                mainGroup = new THREE.Group();
                scene.add(mainGroup);

                // Particles
                spherePos = new Float32Array(TOTAL_COUNT * 3);
                for(let i=0; i<TOTAL_COUNT; i++) {
                    const isCore = i < CORE_COUNT;
                    let r = isCore ? (10 + Math.random() * 2) : (15 + Math.random() * 8);
                    let theta = Math.random() * Math.PI * 2;
                    let phi = Math.acos(2 * Math.random() - 1);
                    spherePos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    spherePos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    spherePos[i*3+2] = r * Math.cos(phi);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(spherePos, 3));
                const material = new THREE.PointsMaterial({
                    color: 0x00ffff, size: 0.15, transparent: true, 
                    opacity: 0.8, blending: THREE.AdditiveBlending, sizeAttenuation: true
                });
                particleSystem = new THREE.Points(geometry, material);
                mainGroup.add(particleSystem);

                // Decorated Tree
                decoratedTreeGroup = new THREE.Group();
                mainGroup.add(decoratedTreeGroup);
                decoratedTreeGroup.visible = false;
                
                const goldMat = new THREE.MeshPhongMaterial({ color: 0xffd700 });
                const redMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                const sphereGeo = new THREE.SphereGeometry(0.4, 16, 16);

                for (let i = 0; i < CORE_COUNT; i++) {
                    const h = Math.random() * 25;
                    const t = h / 25;
                    const rTree = (1 - t) * 8;
                    const angle = t * 25 * Math.PI + Math.random();
                    if (Math.random() > 0.95) {
                        const deco = new THREE.Mesh(sphereGeo, Math.random() > 0.5 ? goldMat : redMat);
                        deco.position.set(rTree * Math.cos(angle), h - 12.5, rTree * Math.sin(angle));
                        decoratedTreeGroup.add(deco);
                    }
                }
                const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                star.position.set(0, 13, 0);
                decoratedTreeGroup.add(star);

                // Snow
                treePos = new Float32Array(HALO_COUNT * 3);
                for (let i = 0; i < HALO_COUNT; i++) {
                    treePos[i*3] = (Math.random() - 0.5) * 40;
                    treePos[i*3+1] = (Math.random() - 0.5) * 45;
                    treePos[i*3+2] = (Math.random() - 0.5) * 40;
                }

                updatePhotoMarkers();

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            // --- H√ÄM T·ªêI ∆ØU H√ìA PH√ÇN B·ªê ·∫¢NH (GI·ªÆ NGUY√äN) ---
            function updatePhotoMarkers() {
                for (let i = mainGroup.children.length - 1; i >= 0; i--) {
                    const child = mainGroup.children[i];
                    if (child.userData && child.userData.isPhotoMarker) {
                        mainGroup.remove(child);
                    }
                }

                const markerGeo = new THREE.SphereGeometry(0.7, 16, 16);
                const markerMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
                const count = PHOTOS.length;
                const phi = Math.PI * (3 - Math.sqrt(5)); 
                const radius = 12.5;

                for (let i = 0; i < count; i++) {
                    const originalY = 1 - (i / (count - 1 + 0.0001)) * 2;
                    const y = originalY * 0.55; // Ch·ªâ d√πng 55% ƒë·ªô cao ·ªü gi·ªØa
                    const radiusAtY = Math.sqrt(1 - y * y); 
                    const theta = phi * i; 
                    const x = Math.cos(theta) * radiusAtY;
                    const z = Math.sin(theta) * radiusAtY;

                    const mesh = new THREE.Mesh(markerGeo, markerMat);
                    mesh.position.set(x * radius, y * radius, z * radius);
                    mesh.userData = { url: PHOTOS[i].url, isPhotoMarker: true };
                    if(isTreeMode) mesh.visible = false;
                    mainGroup.add(mesh);
                }
            }

            async function initAI() {
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });
                    videoElement = document.getElementById('input-video');
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    videoElement.srcObject = stream;
                    videoElement.addEventListener("loadeddata", () => {
                        document.getElementById('loader').style.display = 'none';
                        predictLoop();
                    });
                } catch(e) { console.error(e); }
            }

            function checkFist(lm) {
                const palmSize = Math.sqrt(Math.pow(lm[0].x - lm[9].x, 2) + Math.pow(lm[0].y - lm[9].y, 2));
                const distMiddle = Math.sqrt(Math.pow(lm[0].x - lm[12].x, 2) + Math.pow(lm[0].y - lm[12].y, 2));
                const distRing   = Math.sqrt(Math.pow(lm[0].x - lm[16].x, 2) + Math.pow(lm[0].y - lm[16].y, 2));
                return (distMiddle < palmSize * 1.2) && (distRing < palmSize * 1.2);
            }

            function predictLoop() {
                if (videoElement.currentTime !== lastPinchTime) {
                    const result = handLandmarker.detectForVideo(videoElement, performance.now());
                    const statusEl = document.getElementById('status-text');

                    if (result.landmarks.length > 0) {
                        const lm = result.landmarks[0];
                        const isFist = checkFist(lm);

                        if(isFist) {
                            if(!isTreeMode) {
                                isTreeMode = true;
                                mainGroup.rotation.x = 0; mainGroup.rotation.z = 0; currentRotX = 0;
                                particleSystem.visible = false;
                                decoratedTreeGroup.visible = true;

                                if (!scene.getObjectByName("snowSystem")) {
                                    const snowGeo = new THREE.BufferGeometry();
                                    snowGeo.setAttribute('position', new THREE.BufferAttribute(treePos, 3));
                                    const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true });
                                    const snowSystem = new THREE.Points(snowGeo, snowMat);
                                    snowSystem.name = "snowSystem";
                                    mainGroup.add(snowSystem);
                                } else { scene.getObjectByName("snowSystem").visible = true; }

                                mainGroup.children.forEach(c => { if(c.userData.isPhotoMarker) c.visible = false; });
                            }
                            statusEl.innerHTML = "‚ùÑÔ∏è TREE MODE";
                            lastHandX = lm[9].x; lastHandY = lm[9].y;

                        } else {
                            if(isTreeMode) {
                                isTreeMode = false;
                                currentRotX = 0; mainGroup.rotation.x = 0;
                                particleSystem.visible = true;
                                decoratedTreeGroup.visible = false;
                                if (scene.getObjectByName("snowSystem")) scene.getObjectByName("snowSystem").visible = false;
                                mainGroup.children.forEach(c => { if(c.userData.isPhotoMarker) c.visible = true; });
                            }
                            statusEl.innerHTML = "üîÆ SPHERE CONTROL (LOCKED V)";

                            const currentX = lm[9].x; 
                            let deltaX = lastHandX - currentX; 
                            
                            if (Math.abs(deltaX) < 0.003) deltaX = 0;
                            if (deltaX < 0) deltaX = 0; 
                            currentRotY += deltaX * 8;
                            
                            lastHandX = currentX; lastHandY = lm[9].y;

                            const pinchDist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                            if(pinchDist < 0.05 && Date.now() - lastPinchTime > 1000) {
                                toggleModal();
                                lastPinchTime = Date.now();
                            }
                        }
                    } else {
                        statusEl.innerHTML = "Waiting for hand...";
                    }
                }
                requestAnimationFrame(predictLoop);
            }

            function toggleModal() {
                if(isModalOpen) {
                    document.getElementById('photo-modal').style.display = 'none';
                    isModalOpen = false;
                } else {
                    let closest = null; let maxZ = -999;
                    mainGroup.children.forEach(child => {
                        if(child.userData.isPhotoMarker && child.visible) {
                            const worldPos = new THREE.Vector3();
                            child.getWorldPosition(worldPos);
                            if(worldPos.z > maxZ) { maxZ = worldPos.z; closest = child; }
                        }
                    });
                    if(closest && maxZ > 6) { 
                        document.getElementById('modal-img').src = closest.userData.url;
                        document.getElementById('photo-modal').style.display = 'flex';
                        isModalOpen = true;
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                if (isTreeMode) {
                    mainGroup.rotation.y -= 0.008;
                    mainGroup.rotation.x += (0 - mainGroup.rotation.x) * 0.05;
                    const snowSystem = scene.getObjectByName("snowSystem");
                    if (snowSystem) {
                        snowSystem.rotation.y += 0.002;
                        const positions = snowSystem.geometry.attributes.position.array;
                        for (let i = 1; i < positions.length; i += 3) {
                            positions[i] -= 0.1;
                            if (positions[i] < -25) positions[i] = 25;
                        }
                        snowSystem.geometry.attributes.position.needsUpdate = true;
                    }
                } else {
                    mainGroup.rotation.y += (currentRotY - mainGroup.rotation.y) * 0.08;
                    mainGroup.rotation.x = 0; 
                }
                particleSystem.rotation.y += 0.001; 
                renderer.render(scene, camera);
            }

            initThree();
            initAI();
            animate();
        </script>
    </body>
    </html>